# 悲观锁和乐观锁



## 1、可串行化和禁止脏写

自己对于乐观锁的CAS场景下，数据库执行层面是否还会有写入脏数据的可能一直有疑问。例如以下一条sql如果同时被两个事务进入这条数据，之后同时“看到” “quantity = 3”然后进行更新，有没有这种可能性？

```sql
update quantity = 2 from storage where id = 01 and quantity = 3;
```



所以查书：

1、在并发执行中，通过保证所执行的任何调度的效果都与没有并发执行的调度效果一样，我们可以确保数据库的一致性。也就是说，调度应该在某种意义上等价于一个串行调度。这种调度称为**可串行化**（serializable）调度。

2、**事务的所有隔离性级别都不允许脏写**（dirty write），即如果一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据执行写操作。

所以对于上面举例那条语句不用担心会出现脏写，这是数据库自身负责保障的可串行化调度。

数据库的禁止脏写不允许两个“写操作”的事务同时进入这条数据，所以他们也不会同时“看到” “quantity = 3”然后进行更新。



## 2、悲观锁

回来正式讲一下悲观锁和乐观锁。

首先声明**这是两种对数据库做并发控制的思想**，是两种不同的代码实现逻辑，这不是官方教材传授的数据库基本概念。



### 2.1 什么是悲观锁

当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，**在修改数据之前先锁定，再修改的方式**被称之为“悲观锁”。

这里注意，**悲观锁是真的调用了数据库提供的“锁机制”**。也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据。

之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，**当其他线程想要访问数据时，都需要阻塞挂起**。



### 2.2 共享锁和排他锁

共享锁又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
排他锁又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。



### 2.3 悲观锁的实现

悲观锁的实现，往往依靠数据库提供的锁机制。

在数据库中，悲观锁的流程如下：

1. 在对记录进行修改前，先尝试为该记录加上排他锁(exclusive locks)。
2. 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
3. 如果成功加锁，那么就可以对记录做修改，[事务](https://www.jianshu.com/p/7e76ce65e3ad)完成后就会解锁了。
4. 期间如果有其他对该记录做修改或加排他锁的操作，都会等待解锁或直接抛出异常。



要使用悲观锁，必须关闭 MySQL数据库的自动提交属性。因为 MySQL 默认使用 autocommit 模式，也就是说，当执行一个更新操作后，MySQL 会立刻将结果进行提交。(sql语句：set autocommit=0)

以电商下单扣减库存的过程说明一下悲观锁的使用：

![img](https://upload-images.jianshu.io/upload_images/7038163-6cc15e52ffa4f893.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp)

以上，在对id = 1的记录修改前，先通过 for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。

如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样可以保证当前的数据不会被其它事务修改。

上面提到，使用 select…for update会把数据给锁住，不过需要注意一些锁的级别，MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。



### 2.4 悲观锁的场景

悲观锁适用于低并发下“写操作”的场景。因为悲观锁会将后续线程挂起阻塞，如果阻塞线程数过多比如2min内都无法排到队进入数据，那么http连接都断开了。





## 3、乐观锁



### 3.1 什么是乐观锁

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。

**乐观锁不会使用数据库本身的锁机制**，而是依据数据本身来保证数据的正确性。

具体的实现有两种常用方式：

1、CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。

2、版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。



### 3.2 乐观锁的实现

主要就是两个步骤：冲突检测和数据更新。比较典型的就是 CAS (Compare and Swap)。

CAS 即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS 操作包含三个操作数——内存位置(V)、预期原值(A)和新值(B)。如果内存位置的值(V)与预期原值(A)相匹配，那么处理器会自动将该位置值更新为新值(B)。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。

CAS 有效地说明了“我认为位置(V)应该包含值(A)。如果包含该值，则将新值(B)放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”。

Java 中，sun.misc.Unsafe 类提供了硬件级别的原子操作来实现这个 CAS。java.util.concurrent包下大量的类都使用了这个 Unsafe.java 类的 CAS 操作。



当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。比如前面的扣减库存问题，通过乐观锁可以实现如下：
![img](https://upload-images.jianshu.io/upload_images/7038163-623702054ade5d92.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/490/format/webp)



在更新之前，先查询一下库存表中当前库存数(quantity)，然后在做 update 的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。



### 3.3 乐观锁的场景

乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制。



## 4、悲观锁和乐观锁的比较

|                        | 悲观锁           | 乐观锁 |
| ---------------------- | ---------------- | ------ |
| 是否使用数据库的锁机制 | 是               | 否     |
| 适用的场景             | 低并发下的写操作 | 高并发 |



参考:

[什么是乐观锁，什么是悲观锁](https://www.jianshu.com/p/d2ac26ca6525)

《数据库系统概念》第14章