# JVM 线程安全与锁优化



## 13.3 锁优化

### 13.3.1 自旋锁与自适应自旋

讨论synchronized的互斥同步时，提到了对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大压力。

实际上许多应用对共享数据都只会锁定很短的一段时间，为此切入到内核态是浪费资源的。而且如今大多数计算机都是多核，也就是线程等待的时间也变短了，那还有没有必要切入内核态去挂起，再很快恢复呢？

当目标共享资源被锁住时，我们可以让后面请求锁的那个线程”稍等一会儿“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。”稍等一会儿“的方式，就是让线程执行一个忙循环（自旋），这项技术就是**自旋锁**。



自旋锁在Java 1.4.2中已经引入但默认关闭，使用-XX: +UseSpinning参数可以开启，而从JDK6中改为默认开启。

自旋锁是为了避免短时间等待时挂起线程的不必要开销，如果等待时间过长虚拟机就还是会自动切换到挂起线程中。自旋锁的默认次数是10次，用户也可以使用-XX: PreBlockSpin来自行更改。

自旋锁也是要占用处理器时间的，同样是一种性能开销。



**自适应的自旋锁**：虚拟机加上了一重校验机制，根据前一次在同一锁上的自旋时间及锁的拥有者的状态来决定的。

如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机认为这次自旋也可能再次成功，进而允许自旋更长时间比如100次忙循环。反之，如果某个锁很少被获得，那以后要获取这个锁时都可能直接省略自旋，直接挂起线程。

这里可以看到，虚拟机自己做了预测。



## 13.3.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。

锁消除的主要判定依据来源于逃逸分析（深入理解Java虚拟机第11章）的数据支持，如果判断到一段代码中，在对上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

这里有一个问题：如果代码中没有使用synchronized或者其他lock，是否还需要锁消除？

实际上，锁消除不仅是对程序中主动加入的锁，常用类的函数方法中带锁的都有很多，同步的代码在Java程序中是非常频繁出现的。



实例：

![1593950666636](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1593950666636.png)

在JDK 5之后，如上代码的拼接，是通过StringBuilder对象的连续append操作来的。StringBuilder是非线程安全的，不加锁。

![1593950748636](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1593950748636.png)

这里我们用StringBuffer来说明同步问题，当使用StringBuffer.append方法后，每个append操作都有一个同步块，锁就是sb对象。

虚拟机观察变量sb，经过逃逸分析后会发现它的动态作用域被限制在concatString()方法内部。也就是sb的所有引用都永远不会被逃逸到concatString方法之外，这样安全的锁就可以被消除掉。



## 13.3.3 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。

大多数情况下，上面的原则是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

![1593950748636](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1593950748636.png)

如上代码中，连续的append方法就是连续的互斥同步操作。如果虚拟机探测是有这样一串零碎的操作都对同一个对象加锁，那么将会把加锁同步的范围扩展到整个操作序列的外部，即第一个append操作之前直至最后一个append操作之后。

这样只需要加锁一次，就是锁粗化。